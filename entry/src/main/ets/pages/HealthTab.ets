// HealthTab.ets - ç”¨æˆ·å¥åº· Tabï¼ˆçº¯ UI é™æ€å ä½ç‰ˆï¼‰
//
// âœ… ç›®æ ‡ï¼šå…ˆæŠŠé¡µé¢ç»“æ„/å¸ƒå±€æ­å¥½ï¼ˆæ ‡é¢˜ + ç”¨æˆ·ä¸‹æ‹‰é€‰æ‹© + å¤šå¼ å¥åº·æ•°æ®å¡ç‰‡ï¼‰
// - é™æ€ç”¨æˆ· + KvStore ç”¨æˆ·æ•°æ®æ··åˆå±•ç¤º
// - UI é£æ ¼å°½é‡å¯¹é½ä½ ç»™çš„ ArchiveTabï¼šé¡¶éƒ¨æ ‡é¢˜æ  + å†…å®¹åŒºæ ‡é¢˜å¸¦ä¸‹åˆ’çº¿ + å¡ç‰‡åœ†è§’/æµ…ç°èƒŒæ™¯/è¾¹æ¡†
//
// ğŸ§© äº¤äº’ï¼š
// - ä½¿ç”¨ Select ä¸‹æ‹‰é€‰æ‹©ç”¨æˆ·
// - é€‰æ‹©ä¸åŒç”¨æˆ·åï¼Œæ›´æ–°é¡µé¢å±•ç¤ºçš„é™æ€æ•°æ®ï¼ˆå ä½æ–‡å­—ï¼‰
//
// âš ï¸ æ³¨æ„ï¼š
// - è¯¥ Tab ä¸€èˆ¬ç”± MainTabPage å¼•ç”¨ï¼Œå› æ­¤ä¸åŠ  @Entry
// - å¦‚æœä½ å¸Œæœ›å®ƒå•ç‹¬è¿è¡Œæµ‹è¯•ï¼Œå†åŠ  @Entry å³å¯

import router from '@ohos.router';
import type common from '@ohos.app.ability.common';
import { CareUserStoreManager, CareUserRecord } from '../utils/CareUserStoreManager';
import { HealthRecordStoreManager } from '../utils/HealthRecordStoreManager';
import { HealthData, HealthDataManager, HealthUser } from '../model/HealthData';

class SelectOption {
  value: string;

  constructor(value: string) {
    this.value = value;
  }
}

class HealthUiSnapshot {
  heartRateText: string;   // å¿ƒç‡
  spo2Text: string;        // è¡€æ°§
  tempText: string;        // ä½“æ¸©
  glucoseText: string;     // è¡€ç³–
  bpText: string;          // è¡€å‹
  stressText: string;      // å‹åŠ›
  sleepText: string;       // ç¡çœ 
  updatedText: string;     // æ›´æ–°æ—¶é—´

  constructor(
    heartRateText: string,
    spo2Text: string,
    tempText: string,
    glucoseText: string,
    bpText: string,
    stressText: string,
    sleepText: string,
    updatedText: string
  ) {
    this.heartRateText = heartRateText;
    this.spo2Text = spo2Text;
    this.tempText = tempText;
    this.glucoseText = glucoseText;
    this.bpText = bpText;
    this.stressText = stressText;
    this.sleepText = sleepText;
    this.updatedText = updatedText;
  }
}

class ChartPoint {
  x: number;
  y: number;

  constructor(x: number, y: number) {
    this.x = x;
    this.y = y;
  }
}

class HealthDetailRouteParams {
  type: string;
  userId?: string;

  constructor(type: string, userId?: string) {
    this.type = type;
    if (userId !== undefined) {
      this.userId = userId;
    }
  }
}

/**
 * é€šç”¨å¡ç‰‡ï¼ˆå°å¡ç‰‡ï¼‰ï¼šé¢œè‰²å— + æ ‡é¢˜ + å€¼ï¼ˆå ä½ï¼‰
 */
@Component
struct HealthSmallCard {
  @Prop title: string;
  @Prop value: string;
  @Prop blockColor: number = 0xFFEAF7F2; // é»˜è®¤æµ…ç»¿å—
  @Prop useImage: boolean = false;
  @Prop useBars: boolean = false;
  @Prop image: Resource = $r('app.media.health_example1');
  @Prop barValues: number[] = [];
  @Prop barColor: number = 0xFF2FB86E;
  @Prop @Watch('onBarRefreshChanged') barRefreshSeed: number = 0;
  private barCtx: CanvasRenderingContext2D = new CanvasRenderingContext2D();
  private barReady: boolean = false;

  private onBarRefreshChanged(): void {
    if (!this.barReady) {
      return;
    }
    this.drawBars(this.barCtx);
  }

  build() {
    Column() {
      // é¡¶éƒ¨ï¼šæ ‡é¢˜
      Text(this.title)
        .fontSize(14)
        .fontColor(0xFF666666)
        .margin({ bottom: 6 })

      // ä¸­éƒ¨ï¼šå€¼
      Text(this.value)
        .fontSize(18)
        .fontWeight(FontWeight.Bold)
        .fontColor(0xFF333333)
        .margin({ bottom: 10 })

      // åº•éƒ¨ï¼šé¢œè‰²å—å ä½ / å›¾ç‰‡ç¤ºä¾‹
      if (this.useImage) {
        Image(this.image)
          .width('100%')
          .height(70)
          .objectFit(ImageFit.Cover)
          .borderRadius(10)
          .backgroundColor(this.blockColor)
          .clip(true)
      } else if (this.useBars) {
        Canvas(this.barCtx)
          .width('100%')
          .height(70)
          .borderRadius(10)
          .backgroundColor(this.blockColor)
          .clip(true)
          .onReady(() => {
            this.barReady = true;
            this.drawBars(this.barCtx);
          })
      } else {
        Row()
          .width('100%')
          .height(46)
          .backgroundColor(this.blockColor)
          .borderRadius(10)
      }
    }
    .alignItems(HorizontalAlign.Start)
    .padding({ top: 12, bottom: 4 })
    .borderRadius(12)
    .backgroundColor(0xFFFFFFFF)
    .borderWidth(1)
    .borderColor(0x1A000000)
  }

  private drawBars(ctx: CanvasRenderingContext2D): void {
    const width: number = ctx.width;
    const height: number = ctx.height;
    const paddingX: number = 10;
    const paddingY: number = 8;

    const isEmpty: boolean = this.barValues.length === 0;
    const values: number[] = this.getSafeBarValues();
    let minVal: number = values[0];
    let maxVal: number = values[0];
    for (let i = 1; i < values.length; i++) {
      if (values[i] < minVal) {
        minVal = values[i];
      }
      if (values[i] > maxVal) {
        maxVal = values[i];
      }
    }
    if (maxVal - minVal < 1) {
      maxVal = minVal + 1;
    }

    ctx.clearRect(0, 0, width, height);

    const barAreaWidth: number = width - paddingX * 2;
    const slotWidth: number = barAreaWidth / values.length;
    const barWidth: number = Math.max(6, slotWidth * 0.32);
    const baseY: number = height - paddingY;
    const barMaxHeight: number = height - paddingY * 2 - 10;

    for (let i = 0; i < values.length; i++) {
      const ratio: number = (values[i] - minVal) / (maxVal - minVal);
      const barHeight: number = isEmpty ? 2 : Math.max(8, ratio * barMaxHeight);
      const x: number = paddingX + slotWidth * i + (slotWidth - barWidth) / 2;
      const y: number = baseY - barHeight;

      ctx.fillStyle = this.barColor;
      ctx.fillRect(x, y, barWidth, barHeight);

      ctx.fillStyle = '#FF6A6A';
      ctx.font = '10vp sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      ctx.fillText(values[i].toString(), x + barWidth / 2, y - 2);
    }
  }

  private getSafeBarValues(): number[] {
    if (this.barValues.length > 0) {
      return this.barValues;
    }
    return [0];
  }
}

/**
 * å°å¡ç‰‡æ›²çº¿å›¾ï¼šç”¨äºç¡çœ ç­‰å°å°ºå¯¸æ›²çº¿å±•ç¤º
 */
@Component
struct HealthSmallLineCard {
  @Prop title: string;
  @Prop value: string;
  @Prop blockColor: number = 0xFFEAF7F2;
  @Prop lineValues: number[] = [];
  @Prop lineColor: number = 0xFF2FB86E;
  @Prop @Watch('onLineRefreshChanged') lineRefreshSeed: number = 0;
  private lineCtx: CanvasRenderingContext2D = new CanvasRenderingContext2D();
  private lineReady: boolean = false;

  private onLineRefreshChanged(): void {
    if (!this.lineReady) {
      return;
    }
    this.drawLine(this.lineCtx);
  }

  build() {
    Column() {
      Text(this.title)
        .fontSize(14)
        .fontColor(0xFF666666)
        .margin({ bottom: 6 })

      Text(this.value)
        .fontSize(18)
        .fontWeight(FontWeight.Bold)
        .fontColor(0xFF333333)
        .margin({ bottom: 10 })

      Canvas(this.lineCtx)
        .width('100%')
        .height(70)
        .borderRadius(10)
        .backgroundColor(this.blockColor)
        .clip(true)
        .onReady(() => {
          this.lineReady = true;
          this.drawLine(this.lineCtx);
        })
    }
    .alignItems(HorizontalAlign.Start)
    .padding({ top: 12, bottom: 4 })
    .borderRadius(12)
    .backgroundColor(0xFFFFFFFF)
    .borderWidth(1)
    .borderColor(0x1A000000)
  }

  private drawLine(ctx: CanvasRenderingContext2D): void {
    const width: number = ctx.width;
    const height: number = ctx.height;
    const paddingX: number = 8;
    const paddingY: number = 10;

    const values: number[] = this.getSafeLineValues();
    let minVal: number = values[0];
    let maxVal: number = values[0];
    for (let i = 1; i < values.length; i++) {
      if (values[i] < minVal) {
        minVal = values[i];
      }
      if (values[i] > maxVal) {
        maxVal = values[i];
      }
    }
    if (maxVal - minVal < 1) {
      maxVal = minVal + 1;
    }

    ctx.clearRect(0, 0, width, height);

    const stepX: number = (width - paddingX * 2) / (values.length - 1);
    const chartHeight: number = height - paddingY * 2;
    const points: ChartPoint[] = [];
    for (let i = 0; i < values.length; i++) {
      const ratio: number = (values[i] - minVal) / (maxVal - minVal);
      const x = paddingX + stepX * i;
      const y = height - paddingY - ratio * chartHeight;
      points.push(new ChartPoint(x, y));
    }

    // å¡«å……åŒºåŸŸ
    this.buildCurvePath(ctx, points);
    ctx.lineTo(points[points.length - 1].x, height - paddingY);
    ctx.lineTo(points[0].x, height - paddingY);
    ctx.closePath();

    const fill = ctx.createLinearGradient(0, 0, 0, height);
    fill.addColorStop(0, 'rgba(46, 199, 168, 0.35)');
    fill.addColorStop(1, 'rgba(46, 199, 168, 0)');
    ctx.fillStyle = fill;
    ctx.fill();

    // æŠ˜çº¿æè¾¹
    this.buildCurvePath(ctx, points);
    ctx.strokeStyle = this.toHexColor(this.lineColor);
    ctx.lineWidth = 2;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.stroke();

    // èŠ‚ç‚¹æ•°å€¼
    ctx.fillStyle = this.toHexColor(this.lineColor);
    ctx.font = '10vp sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    for (let i = 0; i < points.length; i++) {
      const point = points[i];
      ctx.beginPath();
      ctx.arc(point.x, point.y, 2.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillText(values[i].toString(), point.x, point.y - 4);
    }
  }

  private buildCurvePath(ctx: CanvasRenderingContext2D, points: ChartPoint[]): void {
    if (points.length < 2) {
      return;
    }
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    for (let i = 0; i < points.length - 1; i++) {
      const p0: ChartPoint = i > 0 ? points[i - 1] : points[i];
      const p1: ChartPoint = points[i];
      const p2: ChartPoint = points[i + 1];
      const p3: ChartPoint = i + 2 < points.length ? points[i + 2] : p2;

      const cp1 = new ChartPoint(
        p1.x + (p2.x - p0.x) / 6,
        p1.y + (p2.y - p0.y) / 6
      );
      const cp2 = new ChartPoint(
        p2.x - (p3.x - p1.x) / 6,
        p2.y - (p3.y - p1.y) / 6
      );

      ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, p2.x, p2.y);
    }
  }

  private getSafeLineValues(): number[] {
    if (this.lineValues.length > 1) {
      return this.lineValues;
    }
    const fallback: number = this.lineValues.length === 1 ? this.lineValues[0] : 0;
    return [fallback, fallback];
  }

  private toHexColor(color: number): string {
    const hex: string = color.toString(16).padStart(8, '0').toUpperCase();
    return `#${hex}`;
  }
}

/**
 * é€šç”¨å¡ç‰‡ï¼ˆå¤§å¡ç‰‡ï¼‰ï¼šç”¨äºé¡¶éƒ¨â€œå¿ƒç‡â€ç±»ä¼¼çš„å¤§å—å±•ç¤º
 */
@Component
struct HealthLargeCard {
  @Prop title: string;
  @Prop value: string;
  @Prop subtitle: string = '';
  @Prop blockColor: number = 0xFFF8EAEA; // é»˜è®¤æµ…çº¢å—
  @Prop chartValues: number[] = [];
  @Prop @Watch('onRefreshSeedChanged') refreshSeed: number = 0;
  private ctx: CanvasRenderingContext2D = new CanvasRenderingContext2D();
  private ready: boolean = false;

  private onRefreshSeedChanged(): void {
    if (!this.ready) {
      return;
    }
    this.drawHeartRate(this.ctx);
  }

  build() {
    Column() {
      Row() {
        Column() {
          Text(this.title)
            .fontSize(14)
            .fontColor(0xFF666666)

          Text(this.value)
            .fontSize(22)
            .fontWeight(FontWeight.Bold)
            .fontColor(0xFF333333)
            .margin({ top: 6 })
        }
        .alignItems(HorizontalAlign.Start)

        Blank().layoutWeight(1)

        // å³ä¸Šè§’ï¼šæ›´æ–°æ—¶é—´å ä½
        if (this.subtitle.length > 0) {
          Text(this.subtitle)
            .fontSize(12)
            .fontColor(0xFF999999)
        }
      }
      .margin({ bottom: 10 })

      // å¿ƒç‡æ›²çº¿ Canvas
      Canvas(this.ctx)
        .width('100%')
        .height(90)
        .borderRadius(12)
        .onReady(() => {
          this.ready = true;
          this.drawHeartRate(this.ctx);
        })
    }
    .alignItems(HorizontalAlign.Start)
    .padding(12)
    .borderRadius(12)
    .backgroundColor(0xFFFFFFFF)
    .borderWidth(1)
    .borderColor(0x1A000000)
  }

  private drawHeartRate(ctx: CanvasRenderingContext2D): void {
    const width: number = ctx.width;
    const height: number = ctx.height;
    const paddingX: number = 8;
    const paddingY: number = 10;

    let values: number[] = [];
    if (this.chartValues.length > 0) {
      values = this.chartValues.slice(0);
    } else {
      values = [0, 0, 0, 0];
    }
    if (values.length < 2) {
      const fallback: number = values.length > 0 ? values[0] : 78;
      while (values.length < 2) {
        values.push(fallback);
      }
    }

    let minVal: number = values[0];
    let maxVal: number = values[0];
    for (let i = 1; i < values.length; i++) {
      if (values[i] < minVal) {
        minVal = values[i];
      }
      if (values[i] > maxVal) {
        maxVal = values[i];
      }
    }
    if (maxVal - minVal < 1) {
      maxVal = minVal + 1;
    }

    ctx.clearRect(0, 0, width, height);

    // èƒŒæ™¯æ¸å˜
    const background = ctx.createLinearGradient(0, 0, 0, height);
    background.addColorStop(0, '#FFEDEE');
    background.addColorStop(1, '#FFFFFF');
    ctx.fillStyle = background;
    ctx.fillRect(0, 0, width, height);

    const stepX: number = (width - paddingX * 2) / (values.length - 1);
    const chartHeight: number = height - paddingY * 2;
    const points: ChartPoint[] = [];
    for (let i = 0; i < values.length; i++) {
      const ratio: number = (values[i] - minVal) / (maxVal - minVal);
      const x = paddingX + stepX * i;
      const y = height - paddingY - ratio * chartHeight;
      points.push(new ChartPoint(x, y));
    }

    // å¡«å……åŒºåŸŸ
    this.buildCurvePath(ctx, points);
    ctx.lineTo(points[points.length - 1].x, height - paddingY);
    ctx.lineTo(points[0].x, height - paddingY);
    ctx.closePath();

    const fill = ctx.createLinearGradient(0, 0, 0, height);
    fill.addColorStop(0, 'rgba(255, 92, 92, 0.35)');
    fill.addColorStop(1, 'rgba(255, 92, 92, 0)');
    ctx.fillStyle = fill;
    ctx.fill();

    // æŠ˜çº¿æè¾¹
    this.buildCurvePath(ctx, points);
    ctx.strokeStyle = '#FF5C5C';
    ctx.lineWidth = 2;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.stroke();

    // èŠ‚ç‚¹ä¸æ•°å€¼
    ctx.fillStyle = '#FF5C5C';
    ctx.font = '12vp sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    for (let i = 0; i < points.length; i++) {
      const point = points[i];
      ctx.beginPath();
      ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
      ctx.fill();
      const labelY: number = Math.max(point.y - 6, 12);
      ctx.fillText(values[i].toString(), point.x, labelY);
    }
  }

  private buildCurvePath(ctx: CanvasRenderingContext2D, points: ChartPoint[]): void {
    if (points.length < 2) {
      return;
    }
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    for (let i = 0; i < points.length - 1; i++) {
      const p0: ChartPoint = i > 0 ? points[i - 1] : points[i];
      const p1: ChartPoint = points[i];
      const p2: ChartPoint = points[i + 1];
      const p3: ChartPoint = i + 2 < points.length ? points[i + 2] : p2;

      const cp1 = new ChartPoint(
        p1.x + (p2.x - p0.x) / 6,
        p1.y + (p2.y - p0.y) / 6
      );
      const cp2 = new ChartPoint(
        p2.x - (p3.x - p1.x) / 6,
        p2.y - (p3.y - p1.y) / 6
      );

      ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, p2.x, p2.y);
    }
  }

  private parseHeartRate(text: string): number {
    let numStr = '';
    for (let i = 0; i < text.length; i++) {
      const ch = text.charAt(i);
      if (ch >= '0' && ch <= '9') {
        numStr += ch;
      } else if (numStr.length > 0) {
        break;
      }
    }
    if (numStr.length === 0) {
      return 0;
    }
    return Number(numStr);
  }
}

@Component
export default struct HealthTab {
  private context: common.UIAbilityContext = getContext() as common.UIAbilityContext;
  private healthStore: HealthRecordStoreManager = HealthRecordStoreManager.getInstance();
  private careStore: CareUserStoreManager = CareUserStoreManager.getInstance();

  @StorageLink('healthDataRefresh') @Watch('onHealthRefreshChanged') private refreshKey: number = 0;
  @StorageLink('careUserRefresh') @Watch('onCareUserRefreshChanged') private careUserRefreshKey: number = 0;
  @StorageLink('isLogin') @Watch('onLoginStateChanged') private isLogin: boolean = false;
  @StorageLink('userName') @Watch('onLoginUserChanged') private ownerName: string = 'æœªç™»å½•';

  /** ç”¨æˆ·åˆ—è¡¨ï¼ˆé™æ€ç”¨æˆ· + åº·å…»ç”¨æˆ·ï¼‰ */
  @State private users: HealthUser[] = [];
  // ä¸‹æ‹‰é€‰é¡¹ï¼ˆå‚ç…§ ServiceReservationPage çš„ Select å†™æ³•ï¼‰
  @State private userOptions: SelectOption[] = [];

  /** å½“å‰é€‰ä¸­çš„ç”¨æˆ·ä¸‹æ ‡ï¼ˆç”¨äº UI å±•ç¤ºä¸æ•°æ®åˆ‡æ¢ï¼‰ */
  @State private selectedIndex: number = 0;

  /** å½“å‰å±•ç¤ºçš„å¥åº·æ•°æ®ï¼ˆé™æ€å ä½ï¼‰ */
  @State private snapshot: HealthUiSnapshot = new HealthUiSnapshot('', '', '', '', '', '', '', '');
  /** å½“å‰å¿ƒç‡æ›²çº¿æ•°æ® */
  @State private heartRateValues: number[] = [];
  /** è§¦å‘æ›²çº¿é‡ç»˜çš„æ ‡è®° */
  @State private heartRateSeed: number = 0;
  /** è¡€æ°§æŸ±çŠ¶å›¾æ•°æ® */
  @State private spo2Bars: number[] = [];
  /** å‹åŠ›æŸ±çŠ¶å›¾æ•°æ® */
  @State private stressBars: number[] = [];
  /** ç¡çœ æ›²çº¿æ•°æ® */
  @State private sleepValues: number[] = [];
  /** è§¦å‘æŸ±çŠ¶å›¾é‡ç»˜ */
  @State private barSeed: number = 0;
  /** è§¦å‘ç¡çœ æ›²çº¿é‡ç»˜ */
  @State private sleepSeed: number = 0;

  aboutToAppear(): void {
    this.loadUsersAndRefresh();
  }

  onPageShow(): void {
    this.loadUsersAndRefresh();
  }

  private onHealthRefreshChanged(): void {
    this.loadUsersAndRefresh();
  }

  private onLoginStateChanged(): void {
    this.loadUsersAndRefresh();
  }

  private onLoginUserChanged(): void {
    this.loadUsersAndRefresh();
  }

  private onCareUserRefreshChanged(): void {
    this.loadUsersAndRefresh();
  }

  /**
   * åˆå¹¶é™æ€ç”¨æˆ·ä¸åº·å…»ç”¨æˆ·
   */
  private async loadUsersAndRefresh(): Promise<void> {
    const merged: HealthUser[] = [];
    const staticUsers: HealthUser[] = HealthDataManager.getUsers();
    for (let i = 0; i < staticUsers.length; i++) {
      merged.push(staticUsers[i]);
    }

    if (this.isLogin && this.ownerName && this.ownerName !== 'æœªç™»å½•') {
      try {
        await this.careStore.initKvStore(this.context);
        const careUsers: CareUserRecord[] = await this.careStore.getUsers(this.ownerName);
        for (let i = 0; i < careUsers.length; i++) {
          const record: CareUserRecord = careUsers[i];
          if (!this.hasUser(merged, record.id, record.name)) {
            merged.push(new HealthUser(record.id, record.name));
          }
        }
      } catch (err) {
        console.error('[HealthTab] load care users failed:', err);
      }
    }

    this.users = merged;
    this.userOptions = merged.map((item: HealthUser) => new SelectOption(item.name));

    if (this.users.length === 0) {
      this.selectedIndex = -1;
      this.resetSnapshot();
      return;
    }

    if (this.selectedIndex < 0 || this.selectedIndex >= this.users.length) {
      this.selectedIndex = 0;
    }

    await this.applySnapshotByIndex(this.selectedIndex);
  }

  private hasUser(list: HealthUser[], id: string, name: string): boolean {
    for (let i = 0; i < list.length; i++) {
      if (list[i].id === id || list[i].name === name) {
        return true;
      }
    }
    return false;
  }

  private resetSnapshot(): void {
    this.snapshot = new HealthUiSnapshot('', '', '', '', '', '', '', '');
    this.heartRateValues = [];
    this.spo2Bars = [];
    this.stressBars = [];
    this.sleepValues = [];
    this.heartRateSeed++;
    this.barSeed++;
    this.sleepSeed++;
  }

  private isStaticUser(userId: string): boolean {
    return userId.indexOf('static_') === 0;
  }

  private async getHealthDataByUserAndType(userId: string, type: string): Promise<HealthData[]> {
    if (this.isStaticUser(userId)) {
      return HealthDataManager.getHealthData(userId, type);
    }
    if (!this.isLogin || !this.ownerName || this.ownerName === 'æœªç™»å½•') {
      return [];
    }
    await this.healthStore.initKvStore(this.context);
    return this.healthStore.getRecordsByUserAndType(this.ownerName, userId, type);
  }

  private orderBySubmitTime(list: HealthData[]): HealthData[] {
    if (list.length === 0) {
      return [];
    }
    if (typeof list[0].submitTime !== 'number') {
      return list;
    }
    const ordered: HealthData[] = list.slice(0);
    ordered.sort((a: HealthData, b: HealthData) => {
      const timeA: number = typeof a.submitTime === 'number' ? a.submitTime : 0;
      const timeB: number = typeof b.submitTime === 'number' ? b.submitTime : 0;
      return timeA - timeB;
    });
    return ordered;
  }

  private async getLatestHealthValue(userId: string, type: string): Promise<HealthData | null> {
    const list: HealthData[] = await this.getHealthDataByUserAndType(userId, type);
    if (list.length === 0) {
      return null;
    }
    const ordered: HealthData[] = this.orderBySubmitTime(list);
    return ordered[ordered.length - 1];
  }

  private formatHealthValue(data: HealthData | null, fallback: string): string {
    if (data === null) {
      return fallback;
    }
    const value: string = data.value;
    const unit: string = data.unit ? data.unit : '';
    if (unit.length > 0 && value.indexOf(unit) < 0) {
      return `${value} ${unit}`;
    }
    return value;
  }

  private async buildSnapshotForUser(userId: string): Promise<HealthUiSnapshot> {
    const heartRate: HealthData | null = await this.getLatestHealthValue(userId, 'å¿ƒç‡');
    const spo2: HealthData | null = await this.getLatestHealthValue(userId, 'è¡€æ°§');
    const temp: HealthData | null = await this.getLatestHealthValue(userId, 'ä½“æ¸©');
    const glucose: HealthData | null = await this.getLatestHealthValue(userId, 'è¡€ç³–');
    const bp: HealthData | null = await this.getLatestHealthValue(userId, 'è¡€å‹');
    const sleep: HealthData | null = await this.getLatestHealthValue(userId, 'ç¡çœ ');
    const stress: HealthData | null = await this.getLatestHealthValue(userId, 'å‹åŠ›');

    const updatedText: string = heartRate ? heartRate.measurementTime : 'åˆšåˆšæ›´æ–°';

    return new HealthUiSnapshot(
      this.formatHealthValue(heartRate, '--'),
      this.formatHealthValue(spo2, '--'),
      this.formatHealthValue(temp, '--'),
      this.formatHealthValue(glucose, '--'),
      this.formatHealthValue(bp, '--'),
      this.formatHealthValue(stress, '--'),
      this.formatHealthValue(sleep, '--'),
      updatedText
    );
  }

  private parseNumber(value: string): number {
    let numStr: string = '';
    for (let i = 0; i < value.length; i++) {
      const ch = value.charAt(i);
      if ((ch >= '0' && ch <= '9') || ch === '.') {
        numStr += ch;
      } else if (numStr.length > 0) {
        break;
      }
    }
    if (numStr.length === 0) {
      return 0;
    }
    return Number(numStr);
  }

  private async getHeartRateSeries(userId: string): Promise<number[]> {
    const list: HealthData[] = this.orderBySubmitTime(
      await this.getHealthDataByUserAndType(userId, 'å¿ƒç‡')
    );
    const values: number[] = [];
    for (let i = 0; i < list.length; i++) {
      const parsed: number = this.parseNumber(list[i].value);
      if (parsed > 0) {
        values.push(parsed);
      }
    }
    return values;
  }

  private async getBarSeries(userId: string, type: string): Promise<number[]> {
    const list: HealthData[] = this.orderBySubmitTime(
      await this.getHealthDataByUserAndType(userId, type)
    );
    const values: number[] = [];
    for (let i = 0; i < list.length; i++) {
      const parsed: number = this.parseNumber(list[i].value);
      if (parsed > 0) {
        values.push(parsed);
      }
    }
    if (values.length === 0) {
      return [];
    }
    const maxCount: number = 4;
    const startIndex: number = Math.max(0, values.length - maxCount);
    return values.slice(startIndex);
  }

  private async getLineSeries(userId: string, type: string): Promise<number[]> {
    const list: HealthData[] = this.orderBySubmitTime(
      await this.getHealthDataByUserAndType(userId, type)
    );
    const values: number[] = [];
    for (let i = 0; i < list.length; i++) {
      const parsed: number = this.parseNumber(list[i].value);
      if (parsed > 0) {
        values.push(parsed);
      }
    }
    return values;
  }

  /**
   * æ ¹æ®ç”¨æˆ·ä¸‹æ ‡åˆ‡æ¢æ•°æ®
   * - çœŸå®é¡¹ç›®ï¼šè¿™é‡Œå¯ä»¥æ”¹æˆ await load(userId) å† this.snapshot = xxx
   */
  private async applySnapshotByIndex(index: number): Promise<void> {
    if (this.users.length === 0) {
      return;
    }
    const safeIndex: number = Math.max(0, Math.min(index, this.users.length - 1));
    this.selectedIndex = safeIndex;

    const userId: string = this.users[safeIndex].id;
    this.snapshot = await this.buildSnapshotForUser(userId);
    this.heartRateValues = await this.getHeartRateSeries(userId);
    this.heartRateSeed++;
    this.spo2Bars = await this.getBarSeries(userId, 'è¡€æ°§');
    this.stressBars = await this.getBarSeries(userId, 'å‹åŠ›');
    this.barSeed++;
    this.sleepValues = await this.getLineSeries(userId, 'ç¡çœ ');
    this.sleepSeed++;
  }

  private openHealthDetail(type: string): void {
    let userId: string | undefined = undefined;
    if (this.users.length > 0 && this.selectedIndex >= 0 && this.selectedIndex < this.users.length) {
      userId = this.users[this.selectedIndex].id;
    }
    const params: HealthDetailRouteParams = new HealthDetailRouteParams(type, userId);
    router.pushUrl({
      url: 'pages/HealthDetailPage',
      params: params
    });
  }

  private openHealthForm(): void {
    router.pushUrl({ url: 'pages/HealthRecordFormPage' });
  }

  build() {
    Stack({alignContent: Alignment.BottomEnd}) {
      Column() {
        // 1) é¡¶éƒ¨æ ‡é¢˜æ ï¼ˆå›ºå®šé«˜åº¦ï¼Œé£æ ¼å¯¹é½ ArchiveTabï¼‰
        Row() {
          Text('å¥åº·')
            .fontSize($r('app.float.home_header_title_font_size'))
            .fontWeight(FontWeight.Normal)
            .fontColor(0xFFFFFFFF)
        }
        .height($r('app.float.home_header_height'))
        .margin({ bottom: 5 })
        .justifyContent(FlexAlign.Center)
        .alignItems(VerticalAlign.Center)

        // 2) æ»šåŠ¨å†…å®¹åŒº
        Scroll() {
          Column() {
            // ---------- é¡µé¢æ ‡é¢˜ï¼šç”¨æˆ·å¥åº· + ä¸‹åˆ’çº¿ ----------
            Row() {
              Column() {
                Text('ç”¨æˆ·å¥åº·')
                  .fontSize(28)
                  .fontWeight(FontWeight.Bold)
                  .fontColor(0xFF333333)

                // ä¸‹åˆ’çº¿ï¼ˆä»æ–‡å­—å¼€å¤´å¼€å§‹ï¼‰
                Row()
                  .width(84)
                  .height(3)
                  .backgroundColor(0xFF333333)
                  .borderRadius(2)
                  .margin({ top: 6 })
              }
              .alignItems(HorizontalAlign.Start)
              .margin({ left: $r('app.float.home_health_section_title_left_margin') })
            }
            .width('100%')
            .margin({ top: 20, bottom: 12 })
            .justifyContent(FlexAlign.Start)
            .alignItems(VerticalAlign.Center)

            Row() {
              // ä¸‹æ‹‰é€‰æ‹©ç”¨æˆ·
              Select(this.userOptions)
                .selected(this.selectedIndex)
                .value(
                  this.userOptions.length > 0 && this.selectedIndex >= 0
                    ? this.userOptions[this.selectedIndex].value
                    : 'æš‚æ— ç”¨æˆ·'
                )
                .font({ size: 16 })
                .fontColor(0xFF333333)
                .onSelect((index: number, value: string) => {
                  this.applySnapshotByIndex(index);
                })
            }
            .width('90%')
            .height(44)
            .padding({ left: 12, right: 12 })
            .backgroundColor(0xFFFFFFFF)
            .borderRadius(10)
            .borderWidth(1)
            .borderColor(0x1A000000)
            .margin({ bottom: 12 })
            // ---------- é¡¶éƒ¨å¤§å¡ç‰‡ï¼ˆå¿ƒç‡æŠ˜çº¿å ä½ï¼‰ ----------
            Column() {
              HealthLargeCard({
                title: 'å¿ƒç‡',
                value: this.snapshot.heartRateText,
                subtitle: this.snapshot.updatedText,
                blockColor: 0xFFF8EAEA,
                chartValues: this.heartRateValues,
                refreshSeed: this.heartRateSeed
              })
            }
            .onClick((): void => {
              this.openHealthDetail('å¿ƒç‡');
            })
            .width('90%')
            .margin({ bottom: 12 })

            // ---------- ä¸¤åˆ—å°å¡ç‰‡åŒºåŸŸï¼ˆé¢œè‰²å— + æ–‡å­—å ä½ï¼‰ ----------
            // ç¬¬ä¸€è¡Œ
            Row({ space: 12 }) {
              Column() {
              HealthSmallCard({
                title: 'è¡€æ°§é¥±å’Œåº¦',
                value: this.snapshot.spo2Text,
                blockColor: 0xFFEAF7F2,
                useBars: true,
                barValues: this.spo2Bars,
                barColor: 0xFF2FB86E,
                barRefreshSeed: this.barSeed
              })
              }
              .onClick((): void => {
                this.openHealthDetail('è¡€æ°§');
              })
              .layoutWeight(1)

              Column() {
                HealthSmallCard({
                  title: 'ä½“æ¸©',
                  value: this.snapshot.tempText,
                  blockColor: 0xFFF3F0FF,
                  useImage: true,
                  image: $r('app.media.health_example1')
                })
              }
              .onClick((): void => {
                this.openHealthDetail('ä½“æ¸©');
              })
              .layoutWeight(1)
            }
            .width('90%')
            .margin({ bottom: 12 })

            // ç¬¬äºŒè¡Œ
            Row({ space: 12 }) {
              Column() {
                HealthSmallCard({
                  title: 'è¡€ç³–',
                  value: this.snapshot.glucoseText,
                  blockColor: 0xFFFFF3E5,
                  useImage: true,
                  image: $r('app.media.health_example2')
                })
              }
              .onClick((): void => {
                this.openHealthDetail('è¡€ç³–');
              })
              .layoutWeight(1)

              Column() {
                HealthSmallCard({
                  title: 'è¡€å‹',
                  value: this.snapshot.bpText,
                  blockColor: 0xFFF8EAEA,
                  useImage: true,
                  image: $r('app.media.health_example3')
                })
              }
              .onClick((): void => {
                this.openHealthDetail('è¡€å‹');
              })
              .layoutWeight(1)
            }
            .width('90%')
            .margin({ bottom: 12 })

            // ç¬¬ä¸‰è¡Œ
            Row({ space: 12 }) {
              Column() {
              HealthSmallCard({
                title: 'å‹åŠ›',
                value: this.snapshot.stressText,
                blockColor: 0xFFEAF7F2,
                useBars: true,
                barValues: this.stressBars,
                barColor: 0xFF2FB86E,
                barRefreshSeed: this.barSeed
              })
              }
              .onClick((): void => {
                this.openHealthDetail('å‹åŠ›');
              })
              .layoutWeight(1)

              Column() {
                HealthSmallLineCard({
                  title: 'ç¡çœ ',
                  value: this.snapshot.sleepText,
                  blockColor: 0xFFEFF7FF,
                  lineValues: this.sleepValues,
                  lineColor: 0xFF2EC7A8,
                  lineRefreshSeed: this.sleepSeed
                })
              }
              .onClick((): void => {
                this.openHealthDetail('ç¡çœ ');
              })
              .layoutWeight(1)
            }
            .width('90%')
            .margin({ bottom: 18 })

            // åº•éƒ¨ç•™ç™½ï¼šé¿å…å†…å®¹è´´åº•/è¢«æ‰‹åŠ¿æ¡é®æŒ¡
            Blank().height(24)
          }
          .width('100%')
          // å…³é”®ï¼šè®©å†…å®¹ä»é¡¶éƒ¨å¼€å§‹æ’å¸ƒï¼ˆé¿å…ç©ºæ•°æ®æ—¶æ ‡é¢˜â€œè·‘ä¸­é—´â€çš„é”™è§‰ï¼‰
          .justifyContent(FlexAlign.Start)
          .alignItems(HorizontalAlign.Center)
        }
        .width('100%')
        .layoutWeight(1)
        .scrollBar(BarState.Off)
        .backgroundColor('#EEEEEE')
      }
      .width('100%')
      .height('100%')
      // ä¸ä½ é¡¹ç›®æ•´ä½“ä¸€è‡´çš„æ¸å˜èƒŒæ™¯ï¼ˆå¯æŒ‰éœ€åˆ é™¤ï¼‰
      .linearGradient({
        angle: 180,
        colors: [
          [0xFF2EC7A8, 0.0],
          [0xFFA0EACD, 0.35],
          [0xFFF5FFFC, 0.5],
          [0xFFFFFFFF, 1.0]
        ]
      })
      .expandSafeArea([SafeAreaType.SYSTEM], [SafeAreaEdge.TOP, SafeAreaEdge.BOTTOM]);

      // å³ä¸‹è§’æ–°å¢å¥åº·æ•°æ®æŒ‰é’®ï¼ˆæµ®å±‚ï¼‰
      Row() {
        Text('+')
          .fontSize(28)
          .fontColor(0xFFFFFFFF)
      }
      .width(54)
      .height(54)
      .backgroundColor($r('app.color.service_button_background_color'))
      .borderRadius(27)
      .justifyContent(FlexAlign.Center)
      .alignItems(VerticalAlign.Center)
      .margin({ right: 20, bottom: 20 })
      .zIndex(10)
      .onClick(() => {
        this.openHealthForm();
      })
    }
    .width('100%')
    .height('100%')
  }
}
